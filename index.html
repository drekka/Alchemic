<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Alchemic by drekka</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Alchemic</h1>
        <h2>An Awesome DI framework for iOS</h2>

        <section id="downloads">
          <a href="https://github.com/drekka/Alchemic/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/drekka/Alchemic/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/drekka/Alchemic" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a id="alchemic-" class="anchor" href="#alchemic-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Alchemic <a href="https://github.com/Carthage/Carthage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible"></a>
</h1>

<p>By Derek Clarkson</p>

<h3>
<a id="other-documents" class="anchor" href="#other-documents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other documents:</h3>

<ul>
<li><a href="./WhatIsDI.md">What is Direct Injection (DI)?</a></li>
<li><a href="./Quick%20guide%20-%20Objective-C.md">Objective-C quick guide</a></li>
<li><a href="./Quick%20guide%20-%20Swift.md">Swift quick guide</a></li>
</ul>

<h3>
<a id="readme" class="anchor" href="#readme" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Readme</h3>

<ul>
<li>
<a href="#intro">Intro</a>

<ul>
<li><a href="#main-features">Main features</a></li>
</ul>
</li>
<li><a href="#swift-support">Swift support</a></li>
<li>
<a href="#installation">Installation</a>

<ul>
<li>
<a href="#carthage"></a><a href="https://github%5C.com/Carthage/Carthage">Carthage</a>
</li>
</ul>
</li>
<li><a href="#alchemics-boot-sequence">Alchemic's boot sequence</a></li>
<li><a href="#adding-alchemic-to-your-code">Adding Alchemic to your code</a></li>
<li>
<a href="#how-alchemic-reads-your-code">How Alchemic reads your code</a>

<ul>
<li><a href="#objective-c-macros">Objective-C macros</a></li>
<li><a href="#swift-functions">Swift functions</a></li>
</ul>
</li>
<li>
<a href="#creating-objects">Creating objects</a>

<ul>
<li><a href="#builders">Builders</a></li>
<li><a href="#declaring-singletons">Declaring singletons</a></li>
<li><a href="#using-initializers">Using initializers</a></li>
<li><a href="#object-factories">Object factories</a></li>
<li><a href="#giving-builders-custom-names">Giving builders custom names</a></li>
<li><a href="#generating-objects-using-methods-or-functions">Generating objects using methods or functions</a></li>
<li><a href="#primary-objects">Primary objects</a></li>
</ul>
</li>
<li>
<a href="#injecting-dependencies">Injecting dependencies</a>

<ul>
<li><a href="#objective-c">Objective-C</a></li>
<li><a href="#swift">Swift</a></li>
<li><a href="#finding-objects">Finding objects</a></li>
<li><a href="#injecting-into-arrays">Injecting into arrays</a></li>
</ul>
</li>
<li>
<a href="#interfacing-with-alchemic">Interfacing with Alchemic</a>

<ul>
<li><a href="#non-managed-objects">Non-managed objects</a></li>
<li><a href="#programmatically-obtaining-objects">Programmatically obtaining objects</a></li>
<li><a href="#asynchronous-startup">Asynchronous startup</a></li>
<li><a href="#managing-the-uiapplicationdelegate-instance">Managing the UIApplicationDelegate instance</a></li>
<li><a href="#callbacks-and-notifications">Callbacks and notifications</a></li>
</ul>
</li>
<li>
<a href="#additional-configuration">Additional configuration</a>

<ul>
<li><a href="#adding-bundles--frameworks">Adding bundles &amp; frameworks</a></li>
</ul>
</li>
<li><a href="#circular-dependency-detection">Circular dependency detection</a></li>
<li>
<a href="#controlling-alchemic">Controlling Alchemic</a>

<ul>
<li><a href="#stopping-alchemic-from-auto-starting">Stopping Alchemic from auto-starting</a></li>
<li><a href="#manually-starting">Manually starting</a></li>
<li><a href="#the-alchemic-context">The Alchemic context</a></li>
</ul>
</li>
<li><a href="#credits">Credits</a></li>
</ul>

<h1>
<a id="intro" class="anchor" href="#intro" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Intro</h1>

<p>Alchemic is a <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> (DI) framework for iOS.  It's based loosely on ideas from the <a href="http://projects.spring.io/spring-framework/">Spring</a> Java framework and after trying out several other iOS DI frameworks. </p>

<h2>
<a id="main-features" class="anchor" href="#main-features" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Main features</h2>

<ul>
<li>Supports both Objective-C and Swift.</li>
<li>Self starting on an asynchronous background thread.</li>
<li>Automatically scans app bundle for declaration.</li>
<li>Classes, initializers or methods as a source of objects.</li>
<li>Singletons, factories or externally sourced objects.</li>
<li>Support for injecting initializer and method arguments. </li>
<li>Variable injection only declarations for injecting externally created objects.</li>
<li>Injection values can be located by class, protocol or name.</li>
<li>Injection values can be constant values.</li>
<li>Declarations can be tagged as primary sources to give them priority.</li>
<li>Automatic array injection by class, protocol or name.</li>
<li>Circular dependency detection.</li>
<li>Concise metalanguage using Objective-C macros or Swift function.</li>
<li>Automatic injection of UIApplicationDelegate dependencies.</li>
</ul>

<h1>
<a id="swift-support" class="anchor" href="#swift-support" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift support</h1>

<p>Alchemic now supports classes written in Swift 2.0+ code. However the way you declare things to Alchemic is different because of various differences between the Objective-C and Swift languages. So the examples used in this document include an Objective-C and Swift example to illustrate the differences.</p>

<p>A major problem for any code attempting to interact with the Swift runtime is the translation from it to the Objective-C equivalents. As Alchemic is written in Objective-C, there are several considerations that must be kept in mind when using Alchemic with Swift source code.</p>

<h3>
<a id="registered-classes" class="anchor" href="#registered-classes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Registered classes</h3>

<p>Any class that you want it's instances to be managed by Alchemic must inherit from <strong>NSObject</strong>. This is because Alchemic is an Objective-C API and internally only works with Objective-C instances.</p>

<h3>
<a id="functions" class="anchor" href="#functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Functions</h3>

<p>When using <strong>AcMethod</strong> or other functions that access swift functions, these functions must be annotated with <strong><a href="https://github.com/objc" class="user-mention">@objc</a></strong>. This ensures that they are visible to Objective-C so that Alchemic can access them.</p>

<h3>
<a id="properties" class="anchor" href="#properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Properties</h3>

<p>When injecting values using <strong>AcInject</strong> into properties, the type of the property must be an Objective-C type. NSObject, NSNumber or any class that extends NSObject.   </p>

<h3>
<a id="arguments" class="anchor" href="#arguments" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Arguments</h3>

<p>Arguments passed to Alchemic functions such as <strong>AcValue</strong> do not have to be Objective-C types. For example, Alchemic can easily understant Swift strings in this context. However they must eventually be resolvable to Objective-C types as per the Swift documentation. </p>

<h1>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installation</h1>

<h2>
<a id="carthage" class="anchor" href="#carthage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/Carthage/Carthage">Carthage</a>
</h2>

<p><a href="https://github.com/Carthage/Carthage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible"></a></p>

<p>If your not using <a href="https://github.com/Carthage/Carthage">Carthage</a>, I would like to suggest that you take a look if you developing for iOS 8+. IMHO it's a far superior dependency manager to Cocoapods, less intrusive and simpler to work with.</p>

<p>Add this to your <strong>Cartfile</strong>:</p>

<pre><code>github "drekka/alchemic" &gt; 1.0
</code></pre>

<p>Then run either the <strong>bootstrap</strong> or <strong>update</strong> carthage commands to download Alchemic from and compile it and it's dependencies into the  <strong>/Carthage/Build/iOS/</strong> directory. You can then include the frameworks into your project the same way you would add any other framework. </p>

<table>
<thead>
<tr>
<th>Framework</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alchemic.framework</td>
<td>This is the Objective-C core of Alchemic. It's required for both Swift and Objective-C projects.</td>
</tr>
<tr>
<td>AlchemicSwift.framework</td>
<td>
<em>ONLY</em> required for Swift projects. This framework provides the bridging functions that enable Swift calls to Alchemic to look as similar as possible to their Objective-C macro equivalents.</td>
</tr>
<tr>
<td>Storyteller.framework</td>
<td>
<a href="https://github.com/drekka/StoryTeller">Story Teller</a> is a alternative logging framework I designed along side Alchemic.</td>
</tr>
<tr>
<td>PEGKit.framework</td>
<td>Used by StoryTeller.</td>
</tr>
</tbody>
</table>

<p><em>Note: You will need to ensure that all of these frameworks are added to your project and copied to the <strong>Frameworks</strong> directory in your app.</em> </p>

<h1>
<a id="alchemics-boot-sequence" class="anchor" href="#alchemics-boot-sequence" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Alchemic's boot sequence</h1>

<p>Alchemic will automatically start itself when your application loads. It follows this logic:</p>

<ol>
<li>Starts itself on a background thread so that your application's startup is not slowed down.</li>
<li>Scan all classes in your app for dependency injection commands. </li>
<li>Resolve all references and configure an internal model based on the found declarations.</li>
<li>Instantiate any classes declared as Singletons and wire up their dependencies.<br>
</li>
<li>Check for a UIApplicationDelegate and if found, injection any dependencies it has declared.</li>
<li>Executes post-startup blocks.</li>
<li>Post the <a href="#finished-loading">"AlchemicFinishedLoading"</a> notification.</li>
</ol>

<p><em>Look at <a href="#asynchronous-startup">Asynchronous startup</a> for more details on Alchemic's starting and how to know when you can access objects.</em></p>

<h1>
<a id="adding-alchemic-to-your-code" class="anchor" href="#adding-alchemic-to-your-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Adding Alchemic to your code</h1>

<p>To use Alchemic, import the Alchemic umbrella header at the top of your implementations (<strong><em>*.m</em></strong> files). </p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>Alchemic/Alchemic.h<span class="pl-pds">&gt;</span></span></pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">import</span> <span class="pl-c1">AlchemicSwift</span></pre></div>

<p><em>Alchemic works with implementations rather than the headers. This means it can access methods and initializers that are not public or visible to other classes.  The advantage of this is that you have the ability to create initializers and methods which only Alchemic can see. Thus simplifying your headers.</em></p>

<h1>
<a id="how-alchemic-reads-your-code" class="anchor" href="#how-alchemic-reads-your-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How Alchemic reads your code</h1>

<p>Alchemic is designed to be as unobtrusive as possible. But it still needs to know what you want it to do. With Objective-C source code it makes use of pre-processor macros to tell it what to do. With Swift source code it uses a specific function with each class and a set of global functions to tell it the details.  </p>

<h2>
<a id="objective-c-macros" class="anchor" href="#objective-c-macros" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Objective-C macros</h2>

<p>In Objective-C classes Alchemic uses pre-processor macros as a form of meta-data, similar to Java's annotations. These macros are generally pretty simple and easy to remember and it's likely that within a short time you will being using them without much thought. </p>

<p>Most of these macros take one or more arguments. For example the <code>AcArg(...)</code> macro takes at least two arguments and possibly more. To help keep the macros susinct and avoid having to type needless boiler plate, they only need the raw class and protocol names, variable names, selectors, etc. For example:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// This macro</span>
<span class="pl-en">AcProtocol</span>(NSCopying)
<span class="pl-c">// generates this code</span>
[ALCProtocol withProtocol:@protocol(NSCopying)]</pre></div>

<p>Some of Alchemic's macros like <code>AcProtocol(...)</code> are designed to be used as arguments to other macros. Others such as <code>AcGet(...)</code> are designed to be used in an Objective-C method. </p>

<p>Some such as <code>AcRegister(...)</code> are designed to be used at the class level and un-wrap themselves into additional class methods. The presense of these methods is how Alchemic recognises the classes it has to manage.</p>

<h2>
<a id="swift-functions" class="anchor" href="#swift-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift functions</h2>

<p>Getting Swift classes to be recognised by Alchemic has to be done differently to Objective-C. For Alchemic to recognise a Swift class, you need to implement a function in it with this signature:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> MyClass {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
        <span class="pl-c">/// Alchemic setup goes here.</span>
    }
}</pre></div>

<p>Alchemic will automatically find and execute every occurance of this function as it starts up. Inside them you place calls to Alchemic's Swift functions to tell it about what you want it to do. These functions are very simular to their Objective-C macro counterparts.</p>

<p><em>Note: It's required that the function is <strong>public</strong> for Alchemic to be able to see it. However sometimes you cannot make the function public (when using inner classes for example). In these situations you can change it to <strong><a href="https://github.com/objc" class="user-mention">@objc</a></strong> instead.</em></p>

<h1>
<a id="creating-objects" class="anchor" href="#creating-objects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating objects</h1>

<p>Before we look at resolving dependencies and injecting values, we first need to look at how we tell Alchemic about the objects we want to create.</p>

<h2>
<a id="builders" class="anchor" href="#builders" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Builders</h2>

<p>Alchamic uses what it calls '<strong>Builders</strong>' to declare how objects are created. They can both build objects and inject dependencies. There are 3 types of builders:</p>

<ul>
<li>
<strong>Class builders</strong> which define information about a class and can build instances of that class. Class builders also hold information about dependencies that the class may have and how they are located and injected.</li>
<li>
<strong>Initializer builders</strong> which define information about a class's initializer and can build instances of the class by executing the initializer and passing it arguments. </li>
<li>
<strong>Method builder</strong> which define information about a method in a class and can build objects by calling the method and returning the result. Method builders are very similar to initializer builder, only differing in how the method is called and that they can return anything the method generates as a return value.</li>
</ul>

<h2>
<a id="declaring-singletons" class="anchor" href="#declaring-singletons" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Declaring singletons</h2>

<p>No matter what kind of appplication you are writing, you will probably have some objects are created once and used everywhere. For example - an object which manages communication with a server or database. These are usually referred to as <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singletons</a>. </p>

<p>There are a number of opinions amongst developers about singletons and how they should be declared and used in code. Alchemic's approach is to assume that builders represent a singleton by default. It keeps one instance of the class in it's context and injects it where ever requested. However it doesn't do anything to stop you creating other instances of that class outside of the context. To tell Alchemic that a particular class is to be treated as a singleton, use this macro in the class's implementation:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@implementation</span> <span class="pl-en">MyClass</span>
<span class="pl-en">AcRegister</span>()
@end</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">class</span> MyClass {
     <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
        AcRegister(cb)
    }
}</pre></div>

<p>This is the simplest form of registering a class with Alchemic. <strong>AcRegister</strong> tells Alchemic that this class need's it's instances managed. When starting, Alchemic will consider any such class for auto-instantiating on startup.</p>

<p><em>Note: <strong>AcRegister</strong> should only be used once in the class.</em></p>

<h2>
<a id="using-initializers" class="anchor" href="#using-initializers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using initializers</h2>

<p>By default, Alchemic will use the standard <code>init</code> method when initializing an instance of a class. However this is not always what you want, so it also provides a way to specify an initializer to use and how to locate any arguments it needs:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@implementation</span> <span class="pl-en">MyClass</span>
<span class="pl-en">AcRegister</span>()
AcInitializer(initWithOtherObject:, AcArg(MyOtherClass, AcClass(MyOtherClass))
-(<span class="pl-k">instancetype</span>) initWithOtherObject:(<span class="pl-k">id</span>) obj {
    <span class="pl-c">// ...</span>
}
<span class="pl-k">@end</span></pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">class</span> MyClass {
    <span class="pl-k">@objc</span> <span class="pl-k">func</span> <span class="pl-en">init</span>(otherObject: <span class="pl-c1">AnyObject</span>) {
        <span class="pl-c">// ...</span>
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
        AcRegister(cb)
        AcInitializer(cb, 
            initializer:<span class="pl-s"><span class="pl-pds">"</span>initWithOtherObject:<span class="pl-pds">"</span></span>, 
            args:AcArg(MyOtherClass<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcClass(MyOtherClass<span class="pl-k">.</span><span class="pl-k">self</span>))
        )
    }
}</pre></div>

<p><strong>AcInitiailizer</strong> tells Alchemic that when it needs to create an instance of MyClass, it should use the passed initializer selector. For each argument the initializer requires, a matching <strong>AcArg</strong> can be specified which define where to get the value for it. </p>

<h3>
<a id="declaring-method-arguments-using-acarg" class="anchor" href="#declaring-method-arguments-using-acarg" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Declaring method arguments using AcArg</h3>

<p><strong>AcArg</strong> helps both <strong>AcInitializer</strong> and <strong>AcMethod</strong> locate argument values to be passed to the methods they are going to execute. The first argument to <strong>AcArg</strong> defines the argument type. This is used when checking candidate values. After that is a list of one or more <a href="#object-search-criteria">Object search criteria</a> that define where to source the value from. </p>

<p>Value for an argument can come from other model objects, or can be defined as constant values. They can also be <strong>nil</strong> if you want to pass a nil. </p>

<p><em>Note: When there is more than one <strong>AcArg</strong> arguments, they must be in the same order as the selector's arguments.</em></p>

<h2>
<a id="object-factories" class="anchor" href="#object-factories" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Object factories</h2>

<p>Sometimes you want to declare a class to Alchemic, but have Alchemic create a new instance every time you need the object. This is known as a <strong><em>Factory</em></strong>. Factories are not as common as singletons in the DI world, but they can be useful in a variety of situations. For example, you could declare an email message class as a factory. Then every time you need one, Alchemic will create a new message object and give it to you with all it's dependencies injected.</p>

<p>To tell Alchemic to treat a class registration as a factory, add <strong>AcFactory</strong> to <strong>AcRegister</strong> like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-en">AcRegister</span>(AcFactory)</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
    AcRegister(cb, AcFactory())
}</pre></div>

<p>Now every time your code requests an instance of the class, a new one will be created and returned. </p>

<p><em>Note that <strong>AcFactory</strong> can also be added to <strong>AcMethod</strong> when defining methods that create instances.</em></p>

<h2>
<a id="giving-builders-custom-names" class="anchor" href="#giving-builders-custom-names" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Giving builders custom names</h2>

<p>Objects are automatically given a name when they are registered and by defaultit's the class name. This name is indexed and can be used to find particular builder registrations quickly. However the name of the class is not always the best choice, so Alchemic provides a way to index the builder under a name of your choosing. Adding the <strong>AcWithName</strong> macro to the builder registration you can specify a custom name to use to index the builder. </p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-en">AcRegister</span>(AcWithName(<span class="pl-s"><span class="pl-pds">@"</span>JSON date formatter<span class="pl-pds">"</span></span>))</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
    AcRegister(cb, AcWithName(<span class="pl-s"><span class="pl-pds">"</span>JSON date formatter<span class="pl-pds">"</span></span>))
}</pre></div>

<p>An example of using naming might be that you register several <code>NSDateFormatter</code> objects with Alchemic and give them names like <em>'JSON date formatter'</em>, <em>'DB date formatter'</em>, etc. Then when you need a <code>NSDateFormatter</code>, you can inject the relevant one by using <strong>AcName</strong> to locate it by name.</p>

<p><em>Note: names <strong>must</strong> be unique. This aids in searching for objects to inject.</em></p>

<h2>
<a id="generating-objects-using-methods-or-functions" class="anchor" href="#generating-objects-using-methods-or-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generating objects using methods or functions</h2>

<p>Sometimes we want to use Objective-C methods or Swift functions to create objects for injecting into dependencies. For example, we might want to generate a <code>Transaction</code> object based on some passed arguments. </p>

<p><em>Unfortunately the Objective-C runtime does not track any information about the argument and return types of methods they way it does for variables. So there is no way for Alchemic to automatically discover information about a method at runtime beyond some very basic information. So we have to tell it a lot more information than we do for classes.</em></p>

<p>Lets take a look at two sample methods which Alchemic will use to create objects:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@implementation</span> <span class="pl-en">Factory</span> {
    <span class="pl-k">int</span> x;
}

<span class="pl-en">AcRegister</span>()

<span class="pl-c">// First a singleton</span>
AcMethod(Database, generateDatabaseConnection)
-(<span class="pl-k">id</span>&lt;DBConnection&gt;) generateDatabaseConnection {
    <span class="pl-c">// Complex connection setup code.</span>
    <span class="pl-k">return</span> dbConn;
}

<span class="pl-c">// And a factory</span>
<span class="pl-en">AcMethod</span>(<span class="pl-c1">NSString</span>, makeATransaction, AcFactory))
-(Transaction *) makeATransaction {
    <span class="pl-k">return</span> [[Transaction <span class="pl-c1">alloc</span>] 
        <span class="pl-c1">initWithName:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span>Transaction <span class="pl-c1">%i</span><span class="pl-pds">"</span></span>, ++x]];
}
<span class="pl-k">@end</span></pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">class</span> Factory {
    <span class="pl-k">var</span> x

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
        AcRegister()
        AcMethod(cb, method:<span class="pl-s"><span class="pl-pds">"</span>generateDatabaseConnection<span class="pl-pds">"</span></span>, type:DBConnection<span class="pl-k">.</span><span class="pl-k">self</span>)
        AcMethod(cb, method:<span class="pl-s"><span class="pl-pds">"</span>makeATransaction<span class="pl-pds">"</span></span>, type:Transaction<span class="pl-k">.</span><span class="pl-k">self</span>, args:AcFactory())
    }

    <span class="pl-c">// First a singleton</span>
    <span class="pl-k">@objc</span> <span class="pl-k">func</span> <span class="pl-en">generateDatabaseConnection</span>() <span class="pl-k">-&gt;</span> DBConnection {
        <span class="pl-c">// Complex connection setup code.</span>
        <span class="pl-k">return</span> dbConn
    }

    <span class="pl-c">// And a factory</span>
    <span class="pl-k">@objc</span> <span class="pl-k">func</span> makeATransaction <span class="pl-k">-&gt;</span> Transaction {
        x<span class="pl-k">++</span>
        <span class="pl-k">return</span> Transaction(<span class="pl-s"><span class="pl-pds">"</span>Transaction <span class="pl-pse">\(</span><span class="pl-s1">x</span><span class="pl-pse">)</span><span class="pl-pds">"</span></span>)
    }
}</pre></div>

<p>We use <strong>AcMethod</strong> to define any method or function that can create objects. This is similar to <strong>AcRegister</strong> in that it registers a source of objects which can be injected into other things. </p>

<p>The first example creates a singleton instance. Alchemic will only call the method once and cache the returned object for later injections. The second example which generates transactions needs to create a new one each time. So it has <strong>AcFactory</strong> set. </p>

<p>Factory registrations also have names so they can be located. Alchemic uses a combination of the class and method selector using the format "<em>ClassName method:signature:</em>". Like class registrations, you can make use of <strong>AcWithName</strong> to give a factory a more meaningful and searchable name. </p>

<p>Now lets take a look at a factory method with arguments:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-en">AcMethod</span>(<span class="pl-c1">NSURLConnection</span>, serverConnectionWithURL:retries:,
    <span class="pl-en">AcWithName</span>(<span class="pl-s"><span class="pl-pds">@"</span>serverConnection<span class="pl-pds">"</span></span>), 
    AcArg(<span class="pl-c1">NSURL</span>, AcName(<span class="pl-s"><span class="pl-pds">@"</span>db-server-url<span class="pl-pds">"</span></span>)),
    AcArg(<span class="pl-c1">NSNumber</span>, AcValue(@<span class="pl-c1">5</span>))
    )
-(<span class="pl-c1">NSURLConnection</span> *) serverConnectionWithURL:(<span class="pl-c1">NSURL</span> *) url 
                                     retries:(<span class="pl-c1">NSNumber</span> *) retries {
    <span class="pl-c">// lots of complex setup code here that creates newConnection.</span>
    <span class="pl-k">return</span> newConnection;
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
    AcRegister()
    AcMethod(cb, method: <span class="pl-s"><span class="pl-pds">"</span>serverConnection:retries:<span class="pl-pds">"</span></span>, type:NSURLConnection<span class="pl-k">.</span><span class="pl-k">self</span>,
        AcWithName(<span class="pl-s"><span class="pl-pds">"</span>serverConnection<span class="pl-pds">"</span></span>),
        AcArg(NSURL<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcName(<span class="pl-s"><span class="pl-pds">"</span>db-server-url<span class="pl-pds">"</span></span>)),
        AcArg(NSNumber<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcValue(<span class="pl-c1">5</span>))
    )
}
<span class="pl-k">@objc</span> <span class="pl-k">func</span> <span class="pl-en">serverConnection</span>(url:NSURL, retries:NSNumber) <span class="pl-k">-&gt;</span> NSURLConnection {
    <span class="pl-c">// lots of complex setup code here that creates newConnection.</span>
    <span class="pl-k">return</span> newConnection;
}</pre></div>

<p>Here we need to use <strong>AcArg</strong> to tell Alchemic where to get the values for each argument. Alchemic uses this information to select appropriate values and pass them as method arguments to the factory method when it's creating the object. </p>

<p>Nils can also be passed as arguments. To do this you use <strong>AcValue</strong> with a nil argument as <strong>AcArg</strong>'s source. Alternatively, if <em>all</em> the remaining arguments to a method are nil, then simply leaving them out has the same effect as setting them to nil.</p>

<p>Here are some other examples of the above declaration with nils: </p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-c">// Passing a nil URL.</span>
<span class="pl-en">AcMethod</span>(<span class="pl-c1">NSURLConnection</span>, serverConnectionWithURL:retries:,
    <span class="pl-en">AcArg</span>(<span class="pl-c1">NSURL</span>, AcValue(<span class="pl-c1">nil</span>)),
    AcArg(<span class="pl-c1">NSNumber</span>, AcValue(@<span class="pl-c1">5</span>))
    )
<span class="pl-c">// Passing a nil retries value.</span>
AcMethod(<span class="pl-c1">NSURLConnection</span>, serverConnectionWithURL:retries:,
    <span class="pl-en">AcArg</span>(<span class="pl-c1">NSURL</span>, AcName(<span class="pl-s"><span class="pl-pds">@"</span>db-server-url<span class="pl-pds">"</span></span>))
    )
<span class="pl-c">// All arguments are nil</span>
AcMethod(<span class="pl-c1">NSURLConnection</span>, serverConnectionWithURL:retries:)</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
    <span class="pl-c">// Passing a nil URL.</span>
    AcMethod(cb, method: <span class="pl-s"><span class="pl-pds">"</span>serverConnection:retries:<span class="pl-pds">"</span></span>, type:NSURLConnection<span class="pl-k">.</span><span class="pl-k">self</span>,
        AcArg(NSURL<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcValue(<span class="pl-c1">nil</span>)),
        AcArg(NSNumber<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcValue(<span class="pl-c1">5</span>))
    )
    <span class="pl-c">// Passing a nil retries.</span>
    AcMethod(cb, method: <span class="pl-s"><span class="pl-pds">"</span>serverConnection:retries:<span class="pl-pds">"</span></span>, type:NSURLConnection<span class="pl-k">.</span><span class="pl-k">self</span>,
        AcArg(NSURL<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcName(<span class="pl-s"><span class="pl-pds">"</span>db-server-url<span class="pl-pds">"</span></span>))
    )
    <span class="pl-c">// All arguments are nil.</span>
    AcMethod(cb, method: <span class="pl-s"><span class="pl-pds">"</span>serverConnection:retries:<span class="pl-pds">"</span></span>, type:NSURLConnection<span class="pl-k">.</span><span class="pl-k">self</span>)
}</pre></div>

<h2>
<a id="primary-objects" class="anchor" href="#primary-objects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Primary objects</h2>

<p>When we have several possible candidate builders for a dependency, we might not want to use custom names to get the exact one we want, but we still need to be able to select just one. Alchemic can define one builder as the default one for these situations. It has the concept of <strong><em>Primary</em></strong> objects which it borrowed from the <a href="http://spring.io"><em>Spring framework</em></a>. </p>

<p>The basic idea is that when multiple builders can satisfy a dependency, you can flag one of them as the <em>'Primary'</em> builder. If Alchemic has more than one possible candidate builder for an injection and one of them is tagged as a primary, it will automatically choose that builder as the one to use. </p>

<p>Here's how to declare a Primary:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-en">AcRegister</span>(AcPrimary)</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb:ALCBuilder) {
    AcRegister(cb, AcPrimary())
}</pre></div>

<p>Primary objects are <strong><em>only</em></strong> checked once a list of candidate builders for ain injection have been located. This ensure that they don't override more specific criteria.</p>

<p><em>Whilst this can solve situations where multiple candidates for a dependency are presents, if Alchemic finds Multiple Primary buildr for a dependency, it will still raise an error.</em></p>

<h3>
<a id="primary-objects-and-testing" class="anchor" href="#primary-objects-and-testing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Primary objects and testing</h3>

<p>Primary builders are most useful in testing. You can register mock or dummy classes from your test suites as Primaries. When Alchemic loads, these test builders will then become the defaults to be injected instead of the production objects, all without having to change a single line of code.</p>

<h1>
<a id="injecting-dependencies" class="anchor" href="#injecting-dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Injecting dependencies</h1>

<p>The main point of a DI framework is to locate an objects dependencies and inject them without you having to write code to do it. In other words, to save the writing of a lot of <a href="https://en.wikipedia.org/wiki/Boilerplate_code">boiler plate</a> code. Alchemic specifies variable dependencies using <strong>AcInject</strong> with a variety of arguments telling it what to inject. </p>

<p><em>Note: Whilst Alchemic can inject values into properties as easily as variables, it does not trigger KVO when doing so. <strong>So don't depend on KVO to detect injections</strong>.</em></p>

<h2>
<a id="objective-c" class="anchor" href="#objective-c" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Objective-C</h2>

<p>Here's a basic Objective-C example:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@interface</span> <span class="pl-en">MyClass</span>
<span class="pl-k">@property</span>(<span class="pl-k">nonatomic</span>, <span class="pl-k">strong</span>, <span class="pl-k">readonly</span>) MyOtherClass *otherObj;
<span class="pl-k">@end</span>

@implementation
<span class="pl-en">AcInject</span>(otherObj)
<span class="pl-c">// Rest of class ...</span>
@end</pre></div>

<p>When being used in Objective-C source code, Alchemic can inject public properties like the above example, but also private properties and variables. You can also use the internal name of properties if you want. So all of the following will work:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@interface</span> <span class="pl-en">MyClass</span>
<span class="pl-k">@property</span>(<span class="pl-k">nonatomic</span>, <span class="pl-k">strong</span>, <span class="pl-k">readonly</span>) MyOtherClass *otherObj;
<span class="pl-k">@end</span>

@implementation {
    YetAnotherClass *_yetAnotherObj;
}

<span class="pl-en">AcInject</span>(otherObj)
AcInject(_otherObj)
AcInject(_yetAnotherObj)
<span class="pl-c">// Rest of class ...</span>
@end</pre></div>

<p>When there is no arguments after the variable name, Alchemic will it up based on the name, work out what class and protocols the variable's type implements, and use that information to locates potential candidates within the context. </p>

<h2>
<a id="swift" class="anchor" href="#swift" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift</h2>

<p>Here's a simple Swift example of specifying an injection:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">class</span> MyClass
    <span class="pl-k">var</span> otherClass:MyOtherObj?
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb: ALCBuilder) {
        AcInject(cb, variable:<span class="pl-s"><span class="pl-pds">"</span>otherObj<span class="pl-pds">"</span></span>, type:MyOtherClass<span class="pl-k">.</span><span class="pl-k">self</span>))
    }
}</pre></div>

<p>There are a couple of rules when specifying injections in Swift: </p>

<ul>
<li>You have to specify the type of the variable in <strong>AcInject</strong>. This is required because the Objective-C runtime that Alchemic uses is not able to determin the type of Swift variables as easily as it can when looking at Objective-C classes.</li>
<li>The Swift variables have to be a tupe that Alchemic can inject. This means classes which extend NSObject. Alchemic cannot inject Swift types such as String or Int. </li>
</ul>

<h2>
<a id="finding-objects" class="anchor" href="#finding-objects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Finding objects</h2>

<p>In order to inject a variable, Alchemic needs a way to locate potential values. Generally it can examine the variable and work out for itself what to inject. But often you might want to provide your own criteria for what gets injected. Plus there are some situations where the runtime cannot provide Alchemic with the information it needs to work out what to inject. </p>

<h3>
<a id="searching-by-class-and-protocols" class="anchor" href="#searching-by-class-and-protocols" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Searching by Class and Protocols</h3>

<p>You can tell Alchemic to ignore the type information of the dependency you are injecting and define your own class and/or protocols to use for selecting candidate objects. Here's an example:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-en">AcInject</span>(otherObj, AcClass(OtherClass))
AcInject(anotherObj, AcProtocol(MyProtocol))</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">Alchemic</span>(cb:ALCBuilder) {
    AcInject(cb, variable:<span class="pl-s"><span class="pl-pds">"</span>otherObj<span class="pl-pds">"</span></span>, type:NSObject<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcClass(OtherClass<span class="pl-k">.</span><span class="pl-k">self</span>))
    AcInject(cb, variable:<span class="pl-s"><span class="pl-pds">"</span>anotherObj<span class="pl-pds">"</span></span>, type:NSObject<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcProtocol(MyProtocol<span class="pl-k">.</span><span class="pl-k">self</span>))
}</pre></div>

<p><strong>AcInject</strong> can take any number of Alchemic commands which are used to locate candidate builders. But you can only specify one <strong>AcClass</strong> and as many <strong>AcProtocol</strong>s macros as you want. It's quite useful when your variables are quite general and you want to inject more specific types. </p>

<p>For example, assuming that <code>AmexAccount</code> implements the <code>Account</code> protocol, we can write this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
@implementation {
    <span class="pl-k">id</span>&lt;Account&gt; *_account;
}
<span class="pl-en">AcInject</span>(_account, AcClass(AmexAccount))
@end</pre></div>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Swift</span>
class {
    var account:Account
    public <span class="pl-k">static</span> func <span class="pl-smi">alchemic</span>(cb:ALCBuilder) {
        <span class="pl-c1">AcInject</span>(cb, variable:<span class="pl-s"><span class="pl-pds">"</span>account<span class="pl-pds">"</span></span>, type:Account.<span class="pl-smi">self</span>, source:<span class="pl-c1">AcClass</span>(AmexAccount.<span class="pl-smi">self</span>))
    } 
}</pre></div>

<p>As programming to protocols is considered a good practice, this sort of injection allows you classes to be quite general in how they refer to other classes, yet you can still locate specific objects to inject.</p>

<h3>
<a id="searching-by-name" class="anchor" href="#searching-by-name" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Searching by Name</h3>

<p>Earlier on we discussed storing objects under custom names in the context so they can be found later. Here's an example of how we use a custom name to locate a specific instance of an object:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@implementation</span> <span class="pl-en">MyClass</span> {
    <span class="pl-c1">NSDateFormatter</span> *_jsonDateFormatter;
}
<span class="pl-en">AcInject</span>(_jsonDateFormatter_, AcName(<span class="pl-s"><span class="pl-pds">@"</span>JSON date formatter<span class="pl-pds">"</span></span>))
@end</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">class</span> MyClass {
    <span class="pl-k">var</span> jsonDateFormatter:NSDateFormatter
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb:ALCBuilder) {
        AcInject(cb, variable:<span class="pl-s"><span class="pl-pds">"</span>jsonDateFormatter<span class="pl-pds">"</span></span>, type:NSDateFormatter<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcName(<span class="pl-s"><span class="pl-pds">"</span>JSON date formatter<span class="pl-pds">"</span></span>))
    }
<span class="pl-k">@end</span>
}</pre></div>

<p>Again we are making a general reference to a <code>NSDateFormatter</code>, but using the name assigned by Alchemic to locate the specific one needed for the injection.</p>

<p><strong>AcName</strong> must occur by itself as a criteria for finding builders as <strong>AcClass</strong> and <strong>AcProtocol</strong> become redundant when is used.</p>

<h3>
<a id="using-constant-values" class="anchor" href="#using-constant-values" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using constant values</h3>

<p>Some times you might want to specify a constant value for a dependency. In this case we can use <strong>AcValue</strong> like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@implementation</span> <span class="pl-en">MyClass</span> {
    <span class="pl-c1">NSString</span> *_message;
}
<span class="pl-en">AcInject</span>(_message, AcValue(<span class="pl-s"><span class="pl-pds">@"</span>hello world<span class="pl-pds">"</span></span>))
@end</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">class</span> MyClass {
    <span class="pl-k">var</span> message:NSString
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb:ALCBuilder) {
        AcInject(cb, variable:<span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>, type:NSString<span class="pl-k">.</span><span class="pl-k">self</span>, AcValue(<span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>))
    }
}</pre></div>

<p><strong>AcValue</strong> cannot occur with any of the search functions. <strong>AcValue</strong> can also pass a nil to the target method if you want.</p>

<h2>
<a id="injecting-into-arrays" class="anchor" href="#injecting-into-arrays" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Injecting into arrays</h2>

<p>Alchemic has another trick up it's sleeve borrowed from the <a href="http://spring.io"><em>Spring framework</em></a>. If you want to get an array of all the objects that match a <a href="#object-search-criteria">search criteria</a>, you can just specify to inject an array variable, and Alchemic will automatically inject a <code>NSArray</code> instance containing all objects that match the criteria. </p>

<p>For example, if we want a list of all NSDateFormatters objects that Alchemic is managing:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@implementation</span> <span class="pl-en">MyClass</span> {
    <span class="pl-c1">NSArray</span>&lt;<span class="pl-c1">NSDateFormatter</span> *&gt; *_dateFormatters;
}
<span class="pl-en">AcInject</span>(_dateFormatters, AcClass(<span class="pl-c1">NSDateFormatter</span>))
@end</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">class</span> MyClass {
    <span class="pl-k">var</span> dateFormatters:NSArray
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb:ALCBuilder) {
        AcInject(cb, variable:<span class="pl-s"><span class="pl-pds">"</span>dateFormatters<span class="pl-pds">"</span></span>, type:NSArray<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcClass(NSDateFormatter<span class="pl-k">.</span><span class="pl-k">self</span>))
    }
}</pre></div>

<p>When processing candidate builders for an inejction, Alchemic will automatically check if the target variable is an array and adjust it's injection accordingly, wrapping objects in NSArrays as required. </p>

<p><em>Note: If the target variable is not an <code>NSArray</code> type and multiple objects are found, them Alchemic will throw an error.</em></p>

<h1>
<a id="interfacing-with-alchemic" class="anchor" href="#interfacing-with-alchemic" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Interfacing with Alchemic</h1>

<p>Now that we know how to declare objects and inject them, lets look at how we retrieve objects in classes and code which is not managed by Alchemic. In other words, how to get Alchemic to work with the rest of your app.</p>

<h2>
<a id="non-managed-objects" class="anchor" href="#non-managed-objects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Non-managed objects</h2>

<p>Not all objects can be created and injected by Alchemic. For example, UIViewControllers in storyboards are created by the storyboard.  However you can still declare dependencies in these classes and get them injected as if Alchemic had created them. </p>

<p>Firstly when registering class injections, either avoid adding <strong>AcRegister</strong>, or add the <strong>AcExternal</strong> flag. Either method will tell Alchemic to use the builder for declaring injections only and to not create any instances. </p>

<p>Later in your code you can make a call to trigger the injection process programmatically like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
-(<span class="pl-k">instancetype</span>) initWithFrame:(<span class="pl-c1">CGRect</span>) aFrame {
    self = [<span class="pl-v">super</span> <span class="pl-c1">initWithFrame:</span>aFrame];
    <span class="pl-k">if</span> (self) {
        <span class="pl-c1">AcInjectDependencies</span>(self);
    }
    <span class="pl-k">return</span> self;
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">func</span> <span class="pl-en">init</span>(frame:CGRect) {
    AcInjectDependencies(<span class="pl-k">self</span>)
}</pre></div>

<p>You can add <strong>AcInjectDependencies</strong> anywhere in the class. For example you might do it in the <code>viewDidLoad</code> method instead. </p>

<p><em>Whilst I looked at several options for automatically injecting storyboard created instances, I did not find any technique that would work well and required less code. So for the moment Alchemic does not inject dependencies into them automatically.</em></p>

<h2>
<a id="programmatically-obtaining-objects" class="anchor" href="#programmatically-obtaining-objects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Programmatically obtaining objects</h2>

<p>Sometimes (in testing for example) you want to get an object from Alchemic without specifying an injection.</p>

<h3>
<a id="getting-objects-using-acget" class="anchor" href="#getting-objects-using-acget" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting objects using <strong>AcGet</strong>
</h3>

<p><strong>AcGet</strong> allows you to search for and return an object (or objects) in a similar fashion to how <strong>AcInject</strong> works. Except it's inline with your code rather than a one off injection and can be accessed as many times as you like.</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
-(<span class="pl-k">void</span>) myMethod {
    <span class="pl-c1">NSDateFormatter</span> *formatter = <span class="pl-c1">AcGet</span>(<span class="pl-c1">NSDateFormatter</span>, <span class="pl-c1">AcName</span>(<span class="pl-s"><span class="pl-pds">@"</span>JSON date formatter<span class="pl-pds">"</span></span>));
    <span class="pl-c">// Do stuff ....</span>
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">func</span> <span class="pl-en">myMethod</span>() {
    <span class="pl-k">var</span> formatter:NSDateFormatter <span class="pl-k">=</span> AcGet(AcName(@<span class="pl-s"><span class="pl-pds">"</span>JSON date formatter<span class="pl-pds">"</span></span>))
    <span class="pl-c">// Do stuff ....</span>
}</pre></div>

<p>In Objective-C <strong>AcGet</strong> requires the first argument to be the type of what will be returned. This type is needed because the runtime does not know what is expected and Alchemic needs this information to finish processing the results. Especially if you are expecting an array back. In Swift, the runtime can deduce the type through Swift generics. </p>

<p>Arguments after the type are search criteria used to find candidate builders. So <strong>AcClass</strong>, <strong>AcProtocol</strong>, <strong>AcName</strong>, or <strong>AcValue</strong> can all be used to either search the context for objects or set a specific value. Note that <strong>AcGet</strong> also does standard Alchemic <code>NSArray</code> processing. For example the following code will return an array of all Alchemic registered date formatters:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
-(<span class="pl-k">void</span>) myMethod {
    <span class="pl-c1">NSArray</span> *formatters = <span class="pl-c1">AcGet</span>(<span class="pl-c1">NSArray</span>, <span class="pl-c1">AcClass</span>(<span class="pl-c1">NSDateFormatter</span>));
    <span class="pl-c">// Do stuff ....</span>
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">func</span> <span class="pl-en">myMethod</span>() {
    <span class="pl-k">var</span> formatters <span class="pl-k">=</span> AcGet(NSArray<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcClass(NSDateFormatter))
    <span class="pl-c">// Do stuff ....</span>
}</pre></div>

<p>Finally, you can leave out the search criteria macros like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
-(<span class="pl-k">void</span>) myMethod {
    <span class="pl-c1">NSDateFormatter</span> *formatter = <span class="pl-c1">AcGet</span>(<span class="pl-c1">NSDateFormatter</span>);
    <span class="pl-c">// Do stuff ....</span>
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">func</span> <span class="pl-en">myMethod</span>() {
    <span class="pl-k">var</span> formatter <span class="pl-k">=</span> AcGet(NSDateFormatter<span class="pl-k">.</span><span class="pl-k">self</span>)
    <span class="pl-c">// Do stuff ....</span>
}</pre></div>

<p>Without any criteria, Alchemic will use the passed return type to determine the search criteria for scanning the model based in it's class and any applicable protocols.</p>

<h3>
<a id="getting-objects-with-acinvoke" class="anchor" href="#getting-objects-with-acinvoke" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting objects with <strong>AcInvoke</strong>
</h3>

<p><strong>AcInvoke</strong> is for when you want to access a declared method or initializer and pass in the arguments manually. But you don't have access to the object it's declared on or may not even know it.  For example, you might declare a factory initializer like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-en">AcInitializer</span>(initWithText:, AcFactory, AcArg(<span class="pl-c1">NSString</span>, AcValue(<span class="pl-s"><span class="pl-pds">@"</span>Default message<span class="pl-pds">"</span></span>)
-(<span class="pl-k">instancetype</span>) initWithText:(<span class="pl-c1">NSString</span> *) message {
    <span class="pl-c">// ...</span>
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">alchemic</span>(cb:ALCBuilder) {
    AcInitializer(cb, initializer:<span class="pl-s"><span class="pl-pds">"</span>initWithMessage:<span class="pl-pds">"</span></span>, 
        args:AcArg(NSString<span class="pl-k">.</span><span class="pl-k">self</span>, source:AcValue(@<span class="pl-s"><span class="pl-pds">"</span>Default message<span class="pl-pds">"</span></span>))
    )
}
<span class="pl-k">func</span> <span class="pl-en">init</span>(message:NSString) {
    <span class="pl-c">// ...</span>
}</pre></div>

<p>In this scenario you want the factory method to give you a new instance of the object when you need it, but with a different message. So you can it like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
-(<span class="pl-k">void</span>) myMethod {
    MyObj *myObj = <span class="pl-c1">AcInvoke</span>(<span class="pl-c1">AcName</span>(<span class="pl-s"><span class="pl-pds">@"</span>MyObj initWithText:<span class="pl-pds">"</span></span>), <span class="pl-s"><span class="pl-pds">@"</span>Message text<span class="pl-pds">"</span></span>);
    <span class="pl-c">// Do stuff ....</span>
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">func</span> <span class="pl-en">myMethod</span>() {
    <span class="pl-k">var</span> myObj <span class="pl-k">=</span> AcInvoke(AcName(<span class="pl-s"><span class="pl-pds">"</span>MyObj initWithText:<span class="pl-pds">"</span></span>), args:<span class="pl-s"><span class="pl-pds">"</span>Message text<span class="pl-pds">"</span></span>)
    <span class="pl-c">// Do stuff ....</span>
}</pre></div>

<p><strong>AcInvoke</strong> will locate all Alchemic declarations that match the first argument, which must be a search function. Normally it's <strong>AcName</strong> because the usual scenario is to be address a specific method or initializer. Once Alchemic has located the method, it then invokes it (in the case of a normal method) or creates an instance using it if it is an initializer. In either case the method being addresses <strong>must</strong> have been registered via <strong>AcInitializer</strong> or <strong>AcMethod</strong> so it can be found. </p>

<p>Also note in the above example, we are using the default name for the method generated by Alchemic. Using <strong>AcInvoke</strong> is one good reason to make use of <strong>AcWithName</strong> to add custom names to registrations.</p>

<h3>
<a id="setting-values-with-acset" class="anchor" href="#setting-values-with-acset" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setting values with <strong>AcSet</strong>
</h3>

<p>Sometimes you have created an object outside of Alchemic, but want Alchemic to manage it. For example, you might have a view controller you want Alchemic to inject into other objects. You can use <strong>AcSet</strong> to do this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
-(<span class="pl-k">void</span>) myMethod {
    MyObj *myObj = ... <span class="pl-c">// create the object. </span>
    <span class="pl-c1">AcSet</span>(myObj, <span class="pl-c1">AcName</span>(<span class="pl-s"><span class="pl-pds">@"</span>abc<span class="pl-pds">"</span></span>));
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">func</span> <span class="pl-en">myMethod</span>() {
    <span class="pl-k">let</span> myObj <span class="pl-k">=</span> <span class="pl-k">...</span> <span class="pl-c">// create the object. </span>
    AcSet(myObj, inBuilderWith:AcName(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>))
}</pre></div>

<p>Alchemic will locate the matching builder for the criteria passed as arguments after the object and set the object as it's value. <strong>ACName</strong> is most useful when setting values as <strong>AcSet</strong> expects there to be only one builder found by the passed crtieria. If zero or more than one builder is returned, <strong>AcSet</strong> will throw an error.</p>

<p><em>Note: that setting a new object for a builder does not effect any previously injected references to the old object. Only injections done after setting the object will receive it.</em></p>

<h2>
<a id="asynchronous-startup" class="anchor" href="#asynchronous-startup" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Asynchronous startup</h2>

<p>Alchemic bootstraps itself in a background thread rather than taking up precious time during your application's startup. However, it also means that any classes that make calls to <strong>AcInjectDependencies</strong> may attempt to execute before Alchemic has finished reading the classes and building it's model of your application.</p>

<p>To address this Alchemic provides an asynchronous callback which can be used in any code that runs at the beginning of your app and needs to ensure that something is execute after Alchemic has finished starting up. </p>

<p>For example, you might have a table view controller that needs data from a singleton that Alchemic injects. To deal with this situation, you should engineer the table view controller to work if the singleton dependency is nil, and to register a callback which refreshes the table after Alchemic has finished loading like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
-(<span class="pl-k">void</span>) viewDidLoad {
    <span class="pl-c1">AcExecuteWhenStarted</span>(^{
        [<span class="pl-v">self</span>.tableView <span class="pl-c1">reloadData</span>];
    });
}</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">func</span> <span class="pl-en">viewDidLoad</span>() {
    AcExecuteWhenStarted {() <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span> <span class="pl-k">in</span>
            <span class="pl-k">self</span><span class="pl-k">.</span>tableView<span class="pl-k">.</span>reloadData()
        }
}</pre></div>

<p>If Alchemic has already finished starting then the block is executed immediately on the current thread. If Alchemic has not started then the block is copied, and executed after Alchemic has finished loading. It will then be executed on the <strong>main thread</strong>.</p>

<h2>
<a id="managing-the-uiapplicationdelegate-instance" class="anchor" href="#managing-the-uiapplicationdelegate-instance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Managing the UIApplicationDelegate instance</h2>

<p>Alchemic has some special processing for <code>UIApplicationDelegates</code>. After starting, Alchemic will automatically search for a <code>UIApplicationDelegate</code> and if it finds one, inject any dependencies it needs. So there is no need to add any <strong>AcRegister</strong> calls to the app delegate class. By default, Alchemic will automatically add the application to its model and set it with your app's instance.</p>

<p><em>Note: You can still use *</em>AcRegister** to give the application delegate a name if you like.*</p>

<h2>
<a id="callbacks-and-notifications" class="anchor" href="#callbacks-and-notifications" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Callbacks and notifications</h2>

<h3>
<a id="dependencies-injected" class="anchor" href="#dependencies-injected" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dependencies injected</h3>

<p>Sometimes it's useful to know when Alchemic has finished injecting values into an object. To facilitate this, a protocol is available which is called after an object has had it's dependencies injected:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
<span class="pl-k">@interface</span> <span class="pl-en">MyClass</span>:<span class="pl-e">NSObject</span>&lt;AlchemicAware&gt;
<span class="pl-k">@end</span> 

<span class="pl-k">@implementation</span> <span class="pl-en">MyClass</span> 
-(<span class="pl-k">void</span>) <span class="pl-en">alchemicDidInjectDependencies</span> {
    <span class="pl-c">// Do stuff</span>
}
<span class="pl-k">@end</span></pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">class</span> MyClass:NSObject<span class="pl-k">&lt;</span>AlchemicAware<span class="pl-k">&gt;</span> {
    <span class="pl-k">func</span> <span class="pl-en">alchemicDidInjectDependencies</span>() {
    <span class="pl-c">// Do stuff</span>
    }
}</pre></div>

<p>This method will automatically be called after all dependencies have been injected. You actually don't need to use the protocol as Alchemic simply looks for the method. The protocol is just a convenience. </p>

<p><em>Also note that this method is <strong>ONLY</strong> called on classes which Alchemic is managing or when *</em>AcInjectDependencies** is used.*</p>

<h3>
<a id="finished-loading" class="anchor" href="#finished-loading" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Finished loading</h3>

<p>Once all singletons have been loaded and injected, Alchemic sends out a notification through the <code>NSNotificationCenter</code> object. There is a constant called <code>AlchemicFinishedLoading</code> in the <code>ALCAlchemic</code> class which can be used like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Obejctive-C</span>
[[<span class="pl-c1">NSNotificationCenter</span> 
    <span class="pl-c1">defaultCenter</span>] <span class="pl-c1">addObserverForName:</span>AlchemicFinishedLoading
                               <span class="pl-c1">object:</span><span class="pl-c1">nil</span>
                                <span class="pl-c1">queue:</span>[<span class="pl-c1">NSOperationQueue</span> <span class="pl-c1">mainQueue</span>]
                           <span class="pl-c1">usingBlock:</span>^(<span class="pl-c1">NSNotification</span> *notification) {
                                     <span class="pl-c">// .. do stuff</span>
                                     }];</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">--</span> need example here <span class="pl-k">--</span></pre></div>

<p>This is most useful for classes which are not managed by Alchemic but still need to know when Alchemic has finished loading.</p>

<h1>
<a id="additional-configuration" class="anchor" href="#additional-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Additional configuration</h1>

<p>Alchemic needs no configuration out of the box. However sometimes there are things you might want to change before it starts. To do this, you need to create one or more classes and implement the <code>ALCConfig</code> protocol on them. Alchemic will automatically locate these classes during startup and read them for additional configuration settings. </p>

<h2>
<a id="adding-bundles--frameworks" class="anchor" href="#adding-bundles--frameworks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Adding bundles &amp; frameworks</h2>

<p>By default, Alchemic scans your apps main bundles sourced from <code>[NSBundle allBundles]</code> looking for Alchemic registrations and methods so it can setup it's model of your app. However you may have code residing in other bundles or frameworks that require injections as well. For example you might have setup a common framework for business logic. </p>

<p>To let Alchemic know that there are further sources of classes that need injections, you need to implement the <code>scanBundlesWithClasses</code> method like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>Alchemic/Alchemic.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">@interface</span> <span class="pl-en">MyAppConfig</span> : <span class="pl-e">NSObject</span>&lt;ALCConfig&gt;
<span class="pl-k">@end</span>

<span class="pl-k">@implementation</span> <span class="pl-en">MyAppConfig</span>
-(<span class="pl-c1">NSArray</span>&lt;Class&gt; scanBundlesWithClasses {
    <span class="pl-k">return</span> @[[MyAppBusinessLogic <span class="pl-c1">class</span>]];
}
@end</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
<span class="pl-k">import</span> <span class="pl-c1">Alchemic</span>
<span class="pl-k">class</span> MyAppConfig:NSObject<span class="pl-k">&lt;</span>ALCConfig<span class="pl-k">&gt;</span>
    <span class="pl-k">func</span> <span class="pl-en">scanBundlesWithClasses</span>() <span class="pl-k">-&gt;</span> NSArray&lt;<span class="pl-c1">AnyClass</span>&gt; {
        <span class="pl-k">return</span> [MyAppBusinessLogic<span class="pl-k">.</span><span class="pl-k">self</span>]
    }
}</pre></div>

<p>During scanning, Alchemic will read the list of classes. For each one, it will locate the bundle or framework that it came from and scan all classes within it. So you only need to refer to a single class to get all classes in it's bundle scanned.</p>

<h1>
<a id="circular-dependency-detection" class="anchor" href="#circular-dependency-detection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Circular dependency detection</h1>

<p>It's possible with dependencies to get into a situation where the dependencies of one object reference a second object which needs the first to resolve. In other words, a chicken and egg situation. </p>

<p>Alchemic attempts to detect these endless loops of dependencies when it starts up by checking through the references that have been created by the macros and looking for loop backs. If it detects one it will immediately throw an exception.</p>

<p>Generally speaking though, they are actually quite hard to create because Alchemic creates as many objects as possible before injecting dependencies. So they are not depending on objects that do not yet exist. </p>

<h1>
<a id="controlling-alchemic" class="anchor" href="#controlling-alchemic" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Controlling Alchemic</h1>

<p>This section covers controlling Alchemic.</p>

<h2>
<a id="stopping-alchemic-from-auto-starting" class="anchor" href="#stopping-alchemic-from-auto-starting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stopping Alchemic from auto-starting</h2>

<p>If for some reason you do not want Alchemic to auto-start (unit testing perhaps), then you can do this by modifying XCode's scheme for the launch like this:</p>

<p><img src="./images/screen-shot-stop-alchemic.png" alt="Stop Alchemic from loading"></p>

<p><strong><em>--alchemic-nostart</em></strong> - disables Alchemic's autostart function.</p>

<h2>
<a id="manually-starting" class="anchor" href="#manually-starting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Manually starting</h2>

<p>Alchemic can programmatically started using:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
[Alchemic <span class="pl-c1">start</span>];</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
Alchemic<span class="pl-k">.</span><span class="pl-c1">start</span>()</pre></div>

<p>But generally speaking, just letting Alchemic autostart is the best way.</p>

<h2>
<a id="the-alchemic-context" class="anchor" href="#the-alchemic-context" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Alchemic context</h2>

<p>Alchemic has a central <em>'Context'</em> which manages all of the objects and classes that Alchemic needs. You generally don't need to do anything directly with the context as Alchemic provides a range of Objective-C <em>macros</em> and Swift functions which will take care of the dirty work for you. However should you need to access it directly, it can be accessed like this:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// Objective-C</span>
[Alchemic <span class="pl-c1">mainContext</span>] ...;</pre></div>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// Swift</span>
Alchemic<span class="pl-k">.</span>mainContext()<span class="pl-k">...</span></pre></div>

<h1>
<a id="credits" class="anchor" href="#credits" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Credits</h1>

<ul>
<li>Thanks to Adam and Vitaly at Odecee who helped me with getting my head around some of the Swift code.</li>
<li>Big Thanks to the guys behind <a href="https://github.com/Carthage/Carthage">Carthage</a> for writing a dependency tool that actual works well with XCode and Git.</li>
<li>Thanks to the guys behind the <a href="https://spring.io">Spring Framework</a>. The work you have done has made my life so much easier on so many Java projects.</li>
<li>Thanks to Mulle Cybernetik for <a href="ocmock.org">OCMock</a>. An outstanding mocking framework for Objective-C that has enabled me to test the un-testable many times.</li>
<li>Thanks to Todd Ditchendorf for <a href="https://github.com/itod/pegkit">PEGKit</a>. I've learned a lot from working with it on <a href="https://github.com/drekka/StoryTeller">Story Teller</a>.</li>
</ul>
      </section>
    </div>

    
  </body>
</html>
